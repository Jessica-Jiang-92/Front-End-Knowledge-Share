## 参考文章
[1. JavaScript 垃圾回收机制](https://juejin.cn/post/6844903858972409869#heading-7)
[2. 深入理解 V8 的垃圾回收原理](https://www.kingmui.cn/2020/09/13/deeply-understand-the-principle-of-V8-garbage-collection/)
[3. V8 之旅： 垃圾回收器](http://newhtml.net/v8-garbage-collection/)

## JavaScript 自动垃圾回收机制
垃圾回收又称为 GC 。在 JavaScript 编码过程中，开发者不需要手动跟踪内存的使用情况，只需要按照要求的标准写 JavaScript 代码，程序运行所需内存的分配以及无用内存的回收完全是自动管理的。其原理是：
- 找出那些不再使用的变量，然后释放掉其占用的内存；
- 垃圾收集器会按照固定的时间间隔（或者预定的收集时间）周期性地执行此操作。

## 局部变量正常的生命周期
局部变量只在函数执行的过程中存在。
在函数执行的过程中，会为局部变量在栈内存（或者堆内存）上分配相应的空间来存储它们的值。在函数中使用这些变量，直到函数执行结束，此时可以释放局部变量的内存供将来需要时使用。

以上情况可以比较容易地判断变量是否有存在的必要，更复杂的情况需要更精细的变量追踪策略。

JavaScript 中的垃圾回收器必须跟踪每个变量是否有用，需要为不再用的变量打上编辑，用于将来回收其占用的内存。标识无用变量的策略通常有2个：标记清除和引用计数。

## 标记清除
mark-and-sweep即是标记清除，也是JS中最为常用的垃圾回收方式，其执行机制如下：
- 当变量进入环境时，就将其标记为“进入环境”
- 当变量离开环境时，就将其标记为“离开环境”
逻辑上，永远不能释放进入环境的变量所占用的内存，因为执行流进入相应的环境时，可能会用到它们。
标记变量的方式有很多种，可以使用标记位的形式记录变量进入环境，也可以单独为“进入环境”和“离开环境”添加变量列表来记录变化。
标记清除采用的收集策略是：
- JavaScript中的垃圾收集器运行时会给存储在内存中的所有变量都加上标记；
- 然后去掉环境中的变量以及被环境中的变量引用的变量的标记；
- 此后，再被加上标记的变量被视为准备删除的变量；
- 最后，垃圾收集器完成内存清除，销毁那些带标记的值并回收其占用的内存空间。
2008年之前，IE、Firefox、Opera、Chrome 和 Safari 的 JavaScript实现使用的均为 标记清除的垃圾回收策略，区别可能在垃圾收集的时间间隔。

## 引用计数
reference counting 即是引用计数，它是另外一种垃圾回收策略。引用计数的本质是跟踪记录每个值被引用的次数，其执行机制如下：
- 当声明一个变量，并将一个引用类型的值赋值给这个变量时，这个值的引用次数为1；
- 若是同一个值又被赋值给另外一个变量，则该值的引用次数再加1；
- 但是如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1；
- 当这个值的引用次数为0时，则无法再访问这个值，就可以回收其占用的内存空间。
垃圾收集器下次运行时，会释放那些引用次数为0的值所占用的内存。引用计数存在一个致命的问题：循环引用，指的是对象A包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。下面的示例就是典型的循环引用的例子：
```
function cycleReference() {
  let objA = new Object();
  let objB =  new Object();

  objA .someOtherObject = objB;
  objB .someOtherObject = objA;
}
```
上述例子中objA和objB通过各自属性相互引用。按照引用计数的策略，两个对象的引用次数均为2.若采用标记清除策略，函数执行完毕，对象离开作用域就不存在相互引用。但采用引用计数后，函数执行完，两个对象的引用次数永不为0，会一直存在内存中，如果多次调用，导致大量内存得不到释放。
IE8浏览器 之前中有一部分对象并不是原生的 JavaScript 对象，可能是使用 C++ 以 COM 对象的形式实现的(BOM, DOM)。而 COM 对象的垃圾收集机制采用的是 引用计数策略。使 IE 的 JavaScript 引擎是使用标记清除策略实现的，但 JavaScript 访问 COM 对象仍然是基于 引用计数策略的。在这种情况下，只要在 IE 中涉及 COM 对象，就可能存在循环引用的问题。

那么该如何避免这种情况呢？
为了避免循环引用，最好在不使用这些对象时，手动断开原生的JavaScript对象与DOM元素之间的连接。IE中的循环引用与手动断开的操作如下所示：
```
// 存在循环引用的情况
let element = document.getElementById('some_element');
let myObj = new Object();
myObj.element = element;
element.someObj = myObj;

// 手动断开循环引用
myObj.element = null;
element.someObj = null;
```
PS：将变量设为null即可切断变量与它之前引用的值之间的连接。下次垃圾收集器运行时，会删除这些值并回收它们占用的内存。为了解决上述问题，IE9及以上版本把BOM和DOM对象都转换成了真正的 JavaScript 对象，避免了两种垃圾回收算法并存引起的问题。

## 垃圾回收的性能问题
垃圾收集器是周期运行的，确定垃圾收集的时间间隔是个非常重要的问题。IE7之前的垃圾收集器是根据内存分配量运行的，即256个变量、4096个对象（数组）字面量或64KB的字符串。达到这些临界值的任何一个，垃圾收集器就会运行。所以就导致如果一个脚本含有很多变量，在整个生命周期中一直保有前面临界值大小的变量，就会频繁触发垃圾回收，会存在严重的性能问题。

IE7重写了垃圾收集历程。新的工作方式为：触发垃圾收集的变量分配、字面量和数组元素的临界值被调整为动态修正。初始值与之前版本相同，如果垃圾收集例程回收的内存低于15%，则临界值加倍。若回收内存分配量超过85%，则临界值重置为默认值。

## JavaScript V8引擎的垃圾回收机制
在JavaScript脚本中，绝大多数对象的生存期很短，只有部分对象的生存期较长，所以V8中的垃圾回收主要使用的是 分代回收(Generational collection)机制。

### 分代回收机制

V8引擎将保存对象的堆（heap）进行了分代：
- 对象最初会被分在新生区（New Space）（1-8M），新生区的内存分配只需要保有一个指向内存区的指针，不断根据内存大小进行递增，当指针达到新生区的末尾，会有一次垃圾回收清理（小周期），清理掉新生区中不再活跃的死对象。
- 对于超过2个小周期的对象，则需要将其移动至老生区（Old Space），老生区在标记-清除/标记-紧缩的过程（大周期）中进行回收。
大周期进行的并不频繁，一次大周期通常是在移动足够多的对象至老生区后才会发生。

### Scavenge 算法
由于垃圾清理发生的比较频繁，清理的过程必须很快。V8中的清理过程使用的是 Scavenge 算法，按照比较经典的 Cheney算法(https://m.tqwba.com/x_d/jishu/428898.html)来实现的。Scavenge 算法的主要过程是：
- 新生区被分为2个大小相等的子区（semi-spaces）：to-space和from-space;
- 大多数的内存分配都是在to-space发生（某些特定对象是在老生区）；
- 当to-space耗尽时，交换to-space和from-space，此时所有的对象都在from-space；
- 然后将from-space中活跃的对象复制到to-space或者老生区中；
- 这些对象被直接压到to-space，提升了Cache的内存局部性，可使内存分配简洁快速。

### 不可忽视的写屏障 Write barriers
如果新生区有某个对象，只有一个指向它的指针，恰好该指针在老生区的对象中，在垃圾回收之前我们如何得知新生区的该对象是否活跃呢？
为解决此问题，V8在写缓冲区有一个列表，其中记录了所有老生区对象指向新生区的情况。新生区对象诞生时不会有指向它的指针，当老生区的对象出现指向新生区对象的指针时，便记录跨区指向，记录行为总是发生在写操作中。

## 标记-清除算法 与 标记-紧缩算法

因为新生区的内存一般都不大，所以使用 Scavenge 算法进行垃圾回收效果比较好。老生区一般占用内存较大，因此采用的是 标记-清除(Mark-Sweep)算法 与 标记-紧缩(Mark-Compact)算法。两种算法都包括两个阶段：标记阶段，清除或紧缩阶段。

### 标记阶段
在标记阶段，堆上所有的活跃对象都会被发现并且标记。
- 每一页都包含用来标记的位图；
- 位图都要占用空间（3.1% on 32-bit，1.6% on 64-bit systems）
- 使用两位二进制标记对象的状态
- 状态为白（white），它尚未被垃圾回收器发现；
- 状态为灰（grey），它已被垃圾回收器发现，但它的邻接对象仍未全部处理完毕；
- 状态为黑（black），它不仅被垃圾回收器发现，而且其所有邻接对象也都处理完毕。
标记算法的核心是深度优先搜索，具体过程为：







