# 动态规划

我们来看经典的背包问题（也叫0-1问题）

![背包](https://user-images.githubusercontent.com/82437559/117530981-bd7e4100-b012-11eb-85d6-25b4c7093265.png)


## 1. 问题描述 

现有n件物品和一个容量为c的背包。第i件物品的重量为w[i]，价值是v[i]。已知对于一件物品必须选择取（用1表示）或者不取（用0表示），
且每件物品只能被取一次（这就是“0-1”的含义）。求放置哪些物品进背包，可使这些物品的重量总和不超过背包容量，且价值总和最大。

## 2. 算法要点分析

对于这个问题，如果使用暴力求解的方式来编程，共n件物品，每个物品的状态为选取或者不选，算法的复杂度是`O(2^n)`，随着n的不断增加，
算法的运行时间将呈指数增长。所以需要找到一个复杂度更低的算法来解决上述的问题，而`动态规划`就是最为常见的上述问题的高效解决方法。

假设有5件物品，其重量分别是w={2, 2, 6, 5, 4}，价值分别是：v={6, 3, 5, 4, 6}，背包容量为10。在数学问题中这是典型的线性规划问题，
我们可以在线性约束范围内求解目标表达式，但如何转换成计算机语言来实现呢？

## 3. 算法的推演关系描述

我们利用一个二维数组m[][]来记录在某个背包容量下，某个物品数量下所对应的最大包内价值，我们可以想象这样一种递推关系：
1. 当背包容量为j，物品数量为1时，此时所能装下的最大价值的物品就是装此物品的包内总价值和不装此物品的包内总价值的最大
值（该算法的核心思想就在于此），此最大值即为`m[1][j]`；
2. 我们将物品数增加1，变为2个物品，第二个物品的重量为w[2]，价值为v[2]，而此时所能装下的最大价值的物品就是装此物品的
包内总价值和不装此物品的包内总价值的最大值，对应的递推公式就是：`m[2][j]=max(m[1][j-w[2]]+v[2], m[1][j])`。max函数
中的左项为当物品数为1，背包容量为j减去第二个物品重量时所能装下的最大价值，然后再加上第二件物品的价值，即先默认肯定能装
第二个物品。相似的max函数中的右项为不装第二件商品，背包容量为j，物品数量为1时所能装下的最大价值。
3. 将上述递推关系1至2推广到i至i+1仍然成立，综上得出一般化递推公式为（i=0表示放入一件商品，依次类推）：
```
（1）i=0  
        当 j < w [0] 时，m [0] [j] =0；
        当j >= w[0]时，m[0][j]=v[0]
（2）i>0  
        当j < w [i]，m [i] [j] = m [i-1] [j]；
        当j >= w[i]，m [i] [j] = max{ m[i-1][j-w[i]]+v[i] ，m[i-1][j] }
```

## 4. 完整的函数代码

```

```













