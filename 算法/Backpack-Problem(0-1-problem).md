# 动态规划之背包问题

我们来看经典的背包问题（也叫0-1问题）

![背包](https://user-images.githubusercontent.com/82437559/117530981-bd7e4100-b012-11eb-85d6-25b4c7093265.png)


## 1. 问题描述 

现有n件物品和一个容量为c的背包。第i件物品的重量为w[i]，价值是v[i]。已知对于一件物品必须选择取（用1表示）或者不取（用0表示），
且每件物品只能被取一次（这就是“0-1”的含义）。求放置哪些物品进背包，可使这些物品的重量总和不超过背包容量，且价值总和最大。

## 2. 算法要点分析

对于这个问题，如果使用暴力求解的方式来编程，共n件物品，每个物品的状态为选取或者不选，算法的复杂度是`O(2^n)`，随着n的不断增加，
算法的运行时间将呈指数增长。所以需要找到一个复杂度更低的算法来解决上述的问题，而`动态规划`就是最为常见的上述问题的高效解决方法。

假设有5件物品，其重量分别是w={2, 2, 6, 5, 4}，价值分别是：v={6, 3, 5, 4, 6}，背包容量为10。在数学问题中这是典型的线性规划问题，
我们可以在线性约束范围内求解目标表达式，但如何转换成计算机语言来实现呢？
我们用一个矩阵来记录结果：
|w|v|i\j|0|1|2|3|4|5|6|7|8|9|10|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|2|6|0||||||||||||
|2|3|1||||||||||||
|6|5|2||||||||||||
|5|4|3||||||||||||
|4|6|4||||||||||||

分析：我们先看第一行，物品0的体积为2，价值为6，当容量为0时，什么也放不下，因此第一个格式只能填0；当j=1时，依然放不下w[0](w[0]=2),
所以依然为0；当j=2到j=10时(都有j>=w[0])，所以能够放下，它的值都是6。将矩阵补充完整如下：

|w|v|i\j|0|1|2|3|4|5|6|7|8|9|10|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|2|6|0|0|0|6|6|6|6|6|6|6|6|6|
|2|3|1||||||||||||
|6|5|2||||||||||||
|5|4|3||||||||||||
|4|6|4||||||||||||

根据第一行，我们可以得到下面的方程：

![11](https://user-images.githubusercontent.com/82437559/117532654-1e117c00-b01b-11eb-8a04-f95b72844bc2.png)
当背包总容量少于物品的体积时，总价值为0，否则就是物品的价值。
我们再看第二行，并补充完整：
| w | v | i\j | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| 2 | 6 | 0 | 0 | 0 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 |
| 2 | 3 | 1 | 0 | 0 | 6 | 6（因为此时j=3，假设放上物品1和2，总共的重量是2+2=4因此放不下物品1（这是第二个物品，第一个物品表示是物品0）） | 9 | 9 | 9 | 9 | 9 | 9 | 9 |
| 6 | 5 | 2 ||||||||||||
| 5 | 4 | 3 ||||||||||||
| 4 | 6 | 4 ||||||||||||

分析：
- 如果选择不放物品1（也就是第二个物品），背包里面还剩下物品0，最大的价值是6；
- 如果选择放物品1，我们需要计算出背包放入物品1后还有多少容量，然后根据容量来查出它的价值，在加上物品1（也就是第二个物品）的价值。
由于我们的目标是尽可能装最值钱的物品， 因此放与不放， 我们需要通过比较来决定，于是有：
![22](https://user-images.githubusercontent.com/82437559/117532959-96c50800-b01c-11eb-9161-3ea88cbbb01a.png)

我们再来看第三行，并补充完整：
| w | v | i\j | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| 2 | 6 | 0 | 0 | 0 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 |
| 2 | 3 | 1 | 0 | 0 | 6 | 6（因为此时j=3，假设放上物品1和2，总共的重量是2+2=4因此放不下物品1（这是第二个物品，第一个物品表示是物品0）） | 9 | 9 | 9 | 9 | 9 | 9 | 9 |
| 6 | 5 | 2 | 0 | 0 | 6 | 6 | 9 | 9 | 9 | 9 | 11（此时只能放下物品0和物品2（它们的重量相加之和正好是8）） | 11 | 14 |
| 5 | 4 | 3 ||||||||||||
| 4 | 6 | 4 ||||||||||||

我们将第1行和第2行的方程整理一下可以得出：
![1](https://user-images.githubusercontent.com/82437559/117533090-5dd96300-b01d-11eb-8710-3cd8e3d78f4a.png)
由此方程，我们可以继续写出剩下两行的数值如下所示：

| w | v | i\j | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| 2 | 6 | 0 | 0 | 0 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 |
| 2 | 3 | 1 | 0 | 0 | 6 | 6（因为此时j=3，假设放上物品1和2，总共的重量是2+2=4因此放不下物品1（这是第二个物品，第一个物品表示是物品0）） | 9 | 9 | 9 | 9 | 9 | 9 | 9 |
| 6 | 5 | 2 | 0 | 0 | 6 | 6 | 9 | 9 | 9 | 9 | 11（此时只能放下物品0和物品2（它们的重量相加之和正好是8）） | 11 | 14 |
| 5 | 4 | 3 | 0 | 0 | 6 | 6 | 9 | 9 | 9 | 10 | 11 | 13 | 14 |
| 4 | 6 | 4 | 0 | 0 | 6 | 6 | 9 | 9 | 12 | 12 | 15 | 15 | 15 |

至此，我们可以得到解为15。根据0-1背包的最优子结构性质，建立计算的递归式。

## 3. 完整的函数代码

```
knapsack(weights, values, W) {
    const n = weights.length - 1;
    const f = [[]];
    for (let j = 0; j <= W; j++) {
      if (j < weights[0]) {
        // 如果容量不能放下物品0的重量，那么价值为0
        f[0][j] = 0;
      } else {
        // 否则等于物体0的价值
        // eslint-disable-next-line prefer-destructuring
        f[0][j] = values[0];
      }
    }
    for (let j = 0; j <= W; j++) {
      for (let i = 1; i <= n; i++) {
        if (!f[i]) {
          // 创建新一行
          f[i] = [];
        }
        if (j < weights[i]) {
          // 等于之前的最优值
          f[i][j] = f[i - 1][j];
        } else {
          f[i][j] = Math.max(f[i - 1][j], f[i - 1][j - weights[i]] + values[i]);
        }
      }
    }
    return f[n][W];
  }
  
  调用：
  const a = knapsack([2,2,6,5,4],[6,3,5,4,6],10);
  console.log(a);
```

## 4. 选择物品

上面讲解了如何求最大值，现在看看具体选择了哪些物品，这个在现实中反而更加有意义。
仔细观察矩阵，从`f(n-1, w)`逆着走向`f(0, 0)`，设i=n-1, j=w。如果有`f(i, j) === f(i-1, j-wj) + vi`，说明背包里面有第i件物品，
因此我们只要当前行不等于上一行的总价值，就能挑出第i件物品，然后j减去该物品的重量，一直找到j=0就可以了。
完整代码如下：
```
findKnapsack(weights, values, W) {
    var n = weights.length;
    var f = new Array(n);
    f[-1] = new Array(W + 1).fill(0);
    var selected = [];
    for (var i = 0; i < n; i++) {
      //注意边界，没有等号
      f[i] = []; //创建当前的二维数组
      for (var j = 0; j <= W; j++) {
        //注意边界，有等号
        if (j < weights[i]) {
          //注意边界， 没有等号
          f[i][j] = f[i - 1][j]; //case 1
        } else {
          f[i][j] = Math.max(f[i - 1][j], f[i - 1][j - weights[i]] + values[i]); //case 2
        }
      }
    }
    var j = W,
      w = 0;
    for (var i = n - 1; i >= 0; i--) {
      if (f[i][j] > f[i - 1][j]) {
        selected.push(i);
        console.log('物品', i, '其重量为', weights[i], '其价格为', values[i]);
        j = j - weights[i];
        w += weights[i];
      }
    }
    console.log('背包最大承重为', W, ' 现在重量为', w, ' 总价值为', f[n - 1][W]);
    return [f[n - 1][W], selected.reverse()];
  }

  调用：
  const b = knapsack([2,2,6,5,4],[6,3,5,4,6],10)
  console.log(b)
```
![1](https://user-images.githubusercontent.com/82437559/117534930-11465580-b026-11eb-99e1-38e52059acd0.png)

我们验证一下就明白：当最优解是15时，选择的物品就是第0，1，4件。

## 参考

[1. 动态规划解决背包问题-JavaScript](https://segmentfault.com/a/1190000012829866)




